name: CD Pipeline - Ubuntu Server Deployment

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main, develop]
  
  # Manual trigger for emergency deployments
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version/Tag to deploy'
        required: false
        default: 'latest'
      skip_tests:
        description: 'Skip deployment tests'
        required: false
        default: false
        type: boolean

env:
  DOCKER_HUB_IMAGE: rickymta/volcanion-face-identified
  APP_NAME: face-verification-api

jobs:
  # Pre-deployment checks
  pre-deployment-checks:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      deploy-staging: ${{ steps.check.outputs.deploy-staging }}
      deploy-production: ${{ steps.check.outputs.deploy-production }}
      image-tag: ${{ steps.check.outputs.image-tag }}
      server-staging: ${{ steps.check.outputs.server-staging }}
      server-production: ${{ steps.check.outputs.server-production }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine deployment targets
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual deployment triggered"
            if [[ "${{ github.event.inputs.environment }}" == "staging" ]]; then
              echo "deploy-staging=true" >> $GITHUB_OUTPUT
              echo "deploy-production=false" >> $GITHUB_OUTPUT
              echo "server-staging=${{ secrets.STAGING_SERVER_HOST }}" >> $GITHUB_OUTPUT
            else
              echo "deploy-staging=false" >> $GITHUB_OUTPUT
              echo "deploy-production=true" >> $GITHUB_OUTPUT
              echo "server-production=${{ secrets.PRODUCTION_SERVER_HOST }}" >> $GITHUB_OUTPUT
            fi
            echo "image-tag=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            # Automatic deployment based on branch
            if [[ "${{ github.event.workflow_run.head_branch }}" == "develop" ]]; then
              echo "deploy-staging=true" >> $GITHUB_OUTPUT
              echo "deploy-production=false" >> $GITHUB_OUTPUT
              echo "server-staging=${{ secrets.STAGING_SERVER_HOST }}" >> $GITHUB_OUTPUT
            elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
              echo "deploy-staging=false" >> $GITHUB_OUTPUT
              echo "deploy-production=true" >> $GITHUB_OUTPUT
              echo "server-production=${{ secrets.PRODUCTION_SERVER_HOST }}" >> $GITHUB_OUTPUT
            else
              echo "deploy-staging=false" >> $GITHUB_OUTPUT
              echo "deploy-production=false" >> $GITHUB_OUTPUT
            fi
            echo "image-tag=${{ github.event.workflow_run.head_sha || github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Verify Docker image exists
        run: |
          IMAGE_TAG="${{ steps.check.outputs.image-tag }}"
          if [[ "$IMAGE_TAG" == "latest" ]]; then
            IMAGE_TAG="${{ github.event.workflow_run.head_sha || github.sha }}"
          fi
          
          echo "Checking if image exists: ${{ env.DOCKER_HUB_IMAGE }}:$IMAGE_TAG"
          
          # Check if image exists on Docker Hub
          if docker manifest inspect ${{ env.DOCKER_HUB_IMAGE }}:$IMAGE_TAG >/dev/null 2>&1; then
            echo "‚úÖ Image found: ${{ env.DOCKER_HUB_IMAGE }}:$IMAGE_TAG"
          else
            echo "‚ùå Image not found: ${{ env.DOCKER_HUB_IMAGE }}:$IMAGE_TAG"
            echo "Falling back to latest tag..."
            if docker manifest inspect ${{ env.DOCKER_HUB_IMAGE }}:latest >/dev/null 2>&1; then
              echo "‚úÖ Fallback image found: ${{ env.DOCKER_HUB_IMAGE }}:latest"
              echo "image-tag=latest" >> $GITHUB_OUTPUT
            else
              echo "‚ùå No suitable image found"
              exit 1
            fi
          fi

  # Deploy to staging Ubuntu server
  deploy-staging:
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.deploy-staging == 'true'
    environment: 
      name: staging
      url: https://staging-api.face-verification.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_PRIVATE_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key
          ssh-keyscan -H ${{ secrets.STAGING_SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory on server
        run: |
          ssh -i ~/.ssh/staging_key ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_HOST }} '
            sudo mkdir -p /opt/face-verification-staging
            sudo chown ${{ secrets.STAGING_SERVER_USER }}:${{ secrets.STAGING_SERVER_USER }} /opt/face-verification-staging
          '

      - name: Copy deployment files to server
        run: |
          # Copy docker-compose and configuration files
          scp -i ~/.ssh/staging_key docker-compose.yml ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_HOST }}:/opt/face-verification-staging/
          scp -i ~/.ssh/staging_key -r nginx/ ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_HOST }}:/opt/face-verification-staging/ || true

      - name: Create staging environment file
        run: |
          ssh -i ~/.ssh/staging_key ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_HOST }} '
            cat > /opt/face-verification-staging/.env.staging << EOF
            ENVIRONMENT=staging
            DEBUG=false
            LOG_LEVEL=INFO
            
            # API Configuration
            API_HOST=0.0.0.0
            API_PORT=8000
            API_SECRET_KEY=${{ secrets.API_SECRET_KEY_STAGING }}
            
            # Database Configuration
            MONGODB_URL=${{ secrets.MONGODB_URL_STAGING }}
            MONGODB_DATABASE=face_verification_staging
            MONGODB_USERNAME=${{ secrets.MONGODB_USERNAME_STAGING }}
            MONGODB_PASSWORD=${{ secrets.MONGODB_PASSWORD_STAGING }}
            
            # Redis Configuration
            REDIS_URL=${{ secrets.REDIS_URL_STAGING }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD_STAGING }}
            
            # Docker Configuration
            DOCKER_IMAGE=${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}
            COMPOSE_PROJECT_NAME=face-verification-staging
            
            # Nginx Configuration
            DOMAIN=staging-api.face-verification.com
            SSL_EMAIL=${{ secrets.SSL_EMAIL }}
            EOF
          '

      - name: Update Docker Compose for staging
        run: |
          ssh -i ~/.ssh/staging_key ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_HOST }} '
            cd /opt/face-verification-staging
            
            # Create staging-specific docker-compose override
            cat > docker-compose.staging.yml << EOF
            version: "3.8"
            
            services:
              face-verification-api:
                image: ${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}
                container_name: face-verification-staging
                restart: unless-stopped
                env_file:
                  - .env.staging
                ports:
                  - "8001:8000"
                depends_on:
                  - mongodb
                  - redis
                volumes:
                  - ./models:/app/models:ro
                  - ./logs:/app/logs
                  - ./temp:/app/temp
                networks:
                  - face-verification-staging
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
            
              mongodb:
                image: mongo:5.0
                container_name: mongodb-staging
                restart: unless-stopped
                environment:
                  MONGO_INITDB_ROOT_USERNAME: \${{ secrets.MONGODB_USERNAME_STAGING }}
                  MONGO_INITDB_ROOT_PASSWORD: \${{ secrets.MONGODB_PASSWORD_STAGING }}
                  MONGO_INITDB_DATABASE: face_verification_staging
                ports:
                  - "27018:27017"
                volumes:
                  - mongodb_data_staging:/data/db
                networks:
                  - face-verification-staging
            
              redis:
                image: redis:7-alpine
                container_name: redis-staging
                restart: unless-stopped
                command: redis-server --requirepass \${{ secrets.REDIS_PASSWORD_STAGING }}
                ports:
                  - "6380:6379"
                volumes:
                  - redis_data_staging:/data
                networks:
                  - face-verification-staging
            
              nginx:
                image: nginx:alpine
                container_name: nginx-staging
                restart: unless-stopped
                ports:
                  - "80:80"
                  - "443:443"
                depends_on:
                  - face-verification-api
                volumes:
                  - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
                  - ./nginx/staging.conf:/etc/nginx/conf.d/default.conf:ro
                  - /etc/letsencrypt:/etc/letsencrypt:ro
                networks:
                  - face-verification-staging
            
            volumes:
              mongodb_data_staging:
              redis_data_staging:
            
            networks:
              face-verification-staging:
                driver: bridge
            EOF
          '

      - name: Deploy to staging server
        run: |
          ssh -i ~/.ssh/staging_key ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_HOST }} '
            cd /opt/face-verification-staging
            
            # Pull the latest image
            docker pull ${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}
            
            # Stop existing containers
            docker-compose -f docker-compose.staging.yml down || true
            
            # Start new deployment
            docker-compose -f docker-compose.staging.yml up -d
            
            # Wait for services to be ready
            echo "Waiting for services to start..."
            sleep 30
            
            # Check container status
            docker-compose -f docker-compose.staging.yml ps
          '

      - name: Verify staging deployment
        run: |
          ssh -i ~/.ssh/staging_key ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_HOST }} '
            cd /opt/face-verification-staging
            
            # Check if containers are running
            if docker-compose -f docker-compose.staging.yml ps | grep -q "Up"; then
              echo "‚úÖ Containers are running"
            else
              echo "‚ùå Containers failed to start"
              docker-compose -f docker-compose.staging.yml logs
              exit 1
            fi
            
            # Health check
            for i in {1..10}; do
              if curl -f http://localhost:8001/health; then
                echo "‚úÖ Health check passed"
                break
              else
                echo "‚è≥ Waiting for health check... ($i/10)"
                sleep 10
              fi
            done
          '

      - name: Run staging smoke tests
        run: |
          # Wait a bit for the service to be fully ready
          sleep 30
          
          STAGING_HOST="${{ secrets.STAGING_SERVER_HOST }}"
          
          # Health check
          echo "Testing health endpoint..."
          if curl -f -s http://$STAGING_HOST:8001/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed"
            exit 1
          fi
          
          # API documentation check
          echo "Testing API docs endpoint..."
          if curl -f -s http://$STAGING_HOST:8001/docs > /dev/null; then
            echo "‚úÖ API docs accessible"
          else
            echo "‚ùå API docs failed"
            exit 1
          fi

      - name: Cleanup old containers and images
        run: |
          ssh -i ~/.ssh/staging_key ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_HOST }} '
            # Remove old unused images
            docker image prune -f
            
            # Remove old containers
            docker container prune -f
          '

      - name: Notify staging deployment
        if: always()
        run: |
          STATUS="${{ job.status }}"
          if [[ "$STATUS" == "success" ]]; then
            echo "üöÄ Staging deployment completed successfully!"
            echo "- Environment: staging"
            echo "- Image: ${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}"
            echo "- Server: ${{ secrets.STAGING_SERVER_HOST }}"
            echo "- URL: http://${{ secrets.STAGING_SERVER_HOST }}:8001"
          else
            echo "‚ùå Staging deployment failed"
          fi

  # Deploy to production Ubuntu server
  deploy-production:
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.deploy-production == 'true'
    environment: 
      name: production
      url: https://api.face-verification.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" > ~/.ssh/production_key
          chmod 600 ~/.ssh/production_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory on server
        run: |
          ssh -i ~/.ssh/production_key ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} '
            sudo mkdir -p /opt/face-verification-production
            sudo chown ${{ secrets.PRODUCTION_SERVER_USER }}:${{ secrets.PRODUCTION_SERVER_USER }} /opt/face-verification-production
          '

      - name: Backup current deployment
        run: |
          ssh -i ~/.ssh/production_key ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} '
            cd /opt/face-verification-production
            
            # Create backup directory
            BACKUP_DIR="/opt/backups/face-verification-$(date +%Y%m%d-%H%M%S)"
            sudo mkdir -p $BACKUP_DIR
            
            # Backup current deployment
            if [ -f docker-compose.production.yml ]; then
              sudo cp -r . $BACKUP_DIR/ || true
              echo "‚úÖ Backup created at $BACKUP_DIR"
            fi
          '

      - name: Copy deployment files to server
        run: |
          # Copy docker-compose and configuration files
          scp -i ~/.ssh/production_key docker-compose.yml ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }}:/opt/face-verification-production/
          scp -i ~/.ssh/production_key -r nginx/ ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }}:/opt/face-verification-production/ || true

      - name: Create production environment file
        run: |
          ssh -i ~/.ssh/production_key ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} '
            cat > /opt/face-verification-production/.env.production << EOF
            ENVIRONMENT=production
            DEBUG=false
            LOG_LEVEL=WARNING
            
            # API Configuration
            API_HOST=0.0.0.0
            API_PORT=8000
            API_SECRET_KEY=${{ secrets.API_SECRET_KEY_PRODUCTION }}
            
            # Database Configuration
            MONGODB_URL=${{ secrets.MONGODB_URL_PRODUCTION }}
            MONGODB_DATABASE=face_verification_production
            MONGODB_USERNAME=${{ secrets.MONGODB_USERNAME_PRODUCTION }}
            MONGODB_PASSWORD=${{ secrets.MONGODB_PASSWORD_PRODUCTION }}
            
            # Redis Configuration
            REDIS_URL=${{ secrets.REDIS_URL_PRODUCTION }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD_PRODUCTION }}
            
            # Docker Configuration
            DOCKER_IMAGE=${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}
            COMPOSE_PROJECT_NAME=face-verification-production
            
            # Nginx Configuration
            DOMAIN=api.face-verification.com
            SSL_EMAIL=${{ secrets.SSL_EMAIL }}
            EOF
          '

      - name: Update Docker Compose for production
        run: |
          ssh -i ~/.ssh/production_key ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} '
            cd /opt/face-verification-production
            
            # Create production-specific docker-compose override
            cat > docker-compose.production.yml << EOF
            version: "3.8"
            
            services:
              face-verification-api:
                image: ${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}
                container_name: face-verification-production
                restart: unless-stopped
                env_file:
                  - .env.production
                ports:
                  - "8000:8000"
                depends_on:
                  - mongodb
                  - redis
                volumes:
                  - ./models:/app/models:ro
                  - ./logs:/app/logs
                  - ./temp:/app/temp
                networks:
                  - face-verification-production
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
                deploy:
                  resources:
                    limits:
                      cpus: "2.0"
                      memory: 4G
                    reservations:
                      cpus: "1.0"
                      memory: 2G
            
              mongodb:
                image: mongo:5.0
                container_name: mongodb-production
                restart: unless-stopped
                environment:
                  MONGO_INITDB_ROOT_USERNAME: \${{ secrets.MONGODB_USERNAME_PRODUCTION }}
                  MONGO_INITDB_ROOT_PASSWORD: \${{ secrets.MONGODB_PASSWORD_PRODUCTION }}
                  MONGO_INITDB_DATABASE: face_verification_production
                ports:
                  - "27017:27017"
                volumes:
                  - mongodb_data_production:/data/db
                  - ./mongodb/mongod.conf:/etc/mongod.conf:ro
                networks:
                  - face-verification-production
                deploy:
                  resources:
                    limits:
                      cpus: "1.0"
                      memory: 2G
            
              redis:
                image: redis:7-alpine
                container_name: redis-production
                restart: unless-stopped
                command: redis-server --requirepass \${{ secrets.REDIS_PASSWORD_PRODUCTION }} --maxmemory 1gb --maxmemory-policy allkeys-lru
                ports:
                  - "6379:6379"
                volumes:
                  - redis_data_production:/data
                networks:
                  - face-verification-production
                deploy:
                  resources:
                    limits:
                      cpus: "0.5"
                      memory: 1G
            
              nginx:
                image: nginx:alpine
                container_name: nginx-production
                restart: unless-stopped
                ports:
                  - "80:80"
                  - "443:443"
                depends_on:
                  - face-verification-api
                volumes:
                  - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
                  - ./nginx/production.conf:/etc/nginx/conf.d/default.conf:ro
                  - /etc/letsencrypt:/etc/letsencrypt:ro
                networks:
                  - face-verification-production
            
            volumes:
              mongodb_data_production:
              redis_data_production:
            
            networks:
              face-verification-production:
                driver: bridge
            EOF
          '

      - name: Deploy to production server with zero downtime
        run: |
          ssh -i ~/.ssh/production_key ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} '
            cd /opt/face-verification-production
            
            # Pull the latest image
            docker pull ${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}
            
            # For zero-downtime deployment, start new container with different name first
            export NEW_CONTAINER_NAME="face-verification-production-new"
            
            # Start new deployment
            docker-compose -f docker-compose.production.yml up -d
            
            # Wait for new service to be ready
            echo "Waiting for new service to start..."
            sleep 45
            
            # Health check for new deployment
            for i in {1..10}; do
              if docker exec face-verification-production curl -f http://localhost:8000/health; then
                echo "‚úÖ New deployment health check passed"
                break
              else
                echo "‚è≥ Waiting for new deployment health check... ($i/10)"
                sleep 10
              fi
            done
            
            # Check container status
            docker-compose -f docker-compose.production.yml ps
          '

      - name: Verify production deployment
        run: |
          ssh -i ~/.ssh/production_key ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} '
            cd /opt/face-verification-production
            
            # Check if containers are running
            if docker-compose -f docker-compose.production.yml ps | grep -q "Up"; then
              echo "‚úÖ Containers are running"
            else
              echo "‚ùå Containers failed to start"
              docker-compose -f docker-compose.production.yml logs
              exit 1
            fi
            
            # Health check
            for i in {1..10}; do
              if curl -f http://localhost:8000/health; then
                echo "‚úÖ Production health check passed"
                break
              else
                echo "‚è≥ Waiting for production health check... ($i/10)"
                sleep 10
              fi
            done
          '

      - name: Run production smoke tests
        run: |
          # Wait a bit for the service to be fully ready
          sleep 30
          
          PRODUCTION_HOST="${{ secrets.PRODUCTION_SERVER_HOST }}"
          
          # Health check
          echo "Testing health endpoint..."
          if curl -f -s http://$PRODUCTION_HOST:8000/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed"
            exit 1
          fi
          
          # API documentation check
          echo "Testing API docs endpoint..."
          if curl -f -s http://$PRODUCTION_HOST:8000/docs > /dev/null; then
            echo "‚úÖ API docs accessible"
          else
            echo "‚ùå API docs failed"
            exit 1
          fi
          
          # Monitoring endpoint check
          echo "Testing monitoring endpoint..."
          if curl -f -s http://$PRODUCTION_HOST:8000/monitoring/health > /dev/null; then
            echo "‚úÖ Monitoring endpoint accessible"
          else
            echo "‚ùå Monitoring endpoint failed"
            exit 1
          fi

      - name: Cleanup old containers and images
        run: |
          ssh -i ~/.ssh/production_key ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} '
            # Remove old unused images (keep last 3 versions)
            docker images ${{ env.DOCKER_HUB_IMAGE }} --format "table {{.Repository}}:{{.Tag}}\t{{.ID}}\t{{.CreatedAt}}" | tail -n +4 | head -n -3 | awk "{print \$2}" | xargs -r docker rmi || true
            
            # Remove old containers
            docker container prune -f
            
            # Remove unused volumes (be careful in production)
            # docker volume prune -f
          '

      - name: Notify production deployment
        if: always()
        run: |
          STATUS="${{ job.status }}"
          if [[ "$STATUS" == "success" ]]; then
            echo "üöÄ Production deployment completed successfully!"
            echo "- Environment: production"
            echo "- Image: ${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}"
            echo "- Server: ${{ secrets.PRODUCTION_SERVER_HOST }}"
            echo "- URL: http://${{ secrets.PRODUCTION_SERVER_HOST }}:8000"
          else
            echo "‚ùå Production deployment failed"
          fi

  # Post-deployment monitoring
  post-deployment-monitoring:
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
      - name: Monitor deployment health
        run: |
          echo "Starting post-deployment monitoring..."
          
          ENDPOINT=""
          ENV_NAME=""
          if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "Monitoring staging deployment..."
            ENDPOINT="http://${{ secrets.STAGING_SERVER_HOST }}:8001"
            ENV_NAME="staging"
          elif [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "Monitoring production deployment..."
            ENDPOINT="http://${{ secrets.PRODUCTION_SERVER_HOST }}:8000"
            ENV_NAME="production"
          fi
          
          if [[ -z "$ENDPOINT" ]]; then
            echo "No successful deployment to monitor"
            exit 0
          fi
          
          # Monitor for 5 minutes
          FAILURES=0
          for i in {1..10}; do
            echo "Health check $i/10 for $ENV_NAME..."
            if curl -f -s "$ENDPOINT/health" > /dev/null; then
              echo "‚úÖ Health check $i passed"
            else
              echo "‚ùå Health check $i failed"
              FAILURES=$((FAILURES + 1))
            fi
            sleep 30
          done
          
          if [[ $FAILURES -gt 3 ]]; then
            echo "‚ùå Too many health check failures ($FAILURES/10). Deployment may be unstable."
            exit 1
          else
            echo "‚úÖ Post-deployment monitoring completed successfully ($FAILURES failures out of 10 checks)"
          fi

      - name: Generate deployment summary
        run: |
          cat << EOF > deployment-summary.md
          # üöÄ Ubuntu Server Deployment Summary
          
          **Date**: $(date)
          **Environment**: ${{ needs.pre-deployment-checks.outputs.deploy-staging == 'true' && 'staging' || 'production' }}
          **Image**: ${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}
          **Status**: ${{ (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success') && '‚úÖ SUCCESS' || '‚ùå FAILED' }}
          
          ## Deployment Details
          - **Staging**: ${{ needs.deploy-staging.result || 'skipped' }}
          - **Production**: ${{ needs.deploy-production.result || 'skipped' }}
          - **Branch**: ${{ github.event.workflow_run.head_branch || github.ref_name }}
          - **Commit**: ${{ github.event.workflow_run.head_sha || github.sha }}
          
          ## Server Details
          ${{ needs.pre-deployment-checks.outputs.deploy-staging == 'true' && format('- **Staging Server**: {0}:8001', secrets.STAGING_SERVER_HOST) || '' }}
          ${{ needs.pre-deployment-checks.outputs.deploy-production == 'true' && format('- **Production Server**: {0}:8000', secrets.PRODUCTION_SERVER_HOST) || '' }}
          
          ## URLs
          ${{ needs.pre-deployment-checks.outputs.deploy-staging == 'true' && format('- **Staging**: http://{0}:8001', secrets.STAGING_SERVER_HOST) || '' }}
          ${{ needs.pre-deployment-checks.outputs.deploy-production == 'true' && format('- **Production**: http://{0}:8000', secrets.PRODUCTION_SERVER_HOST) || '' }}
          
          ## Next Steps
          - ‚úÖ Monitor application performance
          - ‚úÖ Check error rates in logs
          - ‚úÖ Verify all endpoints are functioning correctly
          - ‚úÖ Monitor server resources (CPU, Memory, Disk)
          EOF
          
          cat deployment-summary.md

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v3
        with:
          name: ubuntu-deployment-summary
          path: deployment-summary.md

  # Deployment summary
  deployment-summary:
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, deploy-staging, deploy-production, post-deployment-monitoring]
    if: always()
    steps:
      - name: Generate final summary
        run: |
          echo "# üöÄ Ubuntu Server Deployment Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check job results
          if [[ "${{ needs.pre-deployment-checks.result }}" == "success" ]]; then
            echo "‚úÖ Pre-deployment checks passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Pre-deployment checks failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "‚úÖ Staging deployment passed" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-staging.result }}" == "skipped" ]]; then
            echo "‚è≠Ô∏è Staging deployment skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Staging deployment failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "‚úÖ Production deployment passed" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-production.result }}" == "skipped" ]]; then
            echo "‚è≠Ô∏è Production deployment skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Production deployment failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.post-deployment-monitoring.result }}" == "success" ]]; then
            echo "‚úÖ Post-deployment monitoring passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Post-deployment monitoring failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ env.DOCKER_HUB_IMAGE }}:${{ needs.pre-deployment-checks.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.event.workflow_run.head_branch || github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.event.workflow_run.head_sha || github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Access URLs" >> $GITHUB_STEP_SUMMARY
          echo "- üîÑ **Staging**: http://${{ secrets.STAGING_SERVER_HOST }}:8001" >> $GITHUB_STEP_SUMMARY
          echo "- üöÄ **Production**: http://${{ secrets.PRODUCTION_SERVER_HOST }}:8000" >> $GITHUB_STEP_SUMMARY

      - name: Final status
        run: |
          if [[ "${{ needs.deploy-staging.result }}" == "success" ]] || [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "üéâ Ubuntu server deployment completed successfully!"
            exit 0
          else
            echo "‚ùå Ubuntu server deployment failed. Please check the logs and fix the issues."
            exit 1
          fi
